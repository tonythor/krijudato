---
title: "Finding Value within the Data Science Industry"
author: "Team Krijudato"
date: "October 29, 2023"
output:
  pdf_document: default
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    includes:
      in_header: header.html
    css: ./lab.css
    highlight: pygments
    theme: cerulean
editor_options: 
  chunk_output_type: console
---

---

### Project Overview
![](./images/overview.svg)

---

### Data Engineering Overview

Our data engineerging pipeline does four things.

1. For each year, download raw survey data from our s3 cache.
2. Normalize the structure of each year, minor cleaning, tehn union together. 
3. Explode wide certain multivalue columns, like "PlatformWorkedWith" which contains both AWS and Google Cloud.
4. Save the CSV file in the root directory so the markdown can load it from cache.

[funcitons.r](https://github.com/tonythor/krijudato/blob/develop/functions.r) contains our data engineering pipeline code.

Also, to prepare for this project, we had to do a column analysis. If you'd like to see what went into that, review and run our [admin.r](https://github.com/tonythor/krijudato/blob/develop/admin.r) file.

---

_load and prepare base data..._

```{r, globaloptions, warning = FALSE, message = FALSE, output=FALSE}
packages <- c("dplyr","tidyr", "ggplot2", "stringr", "gt", "gridExtra")
lapply(packages, library, character.only = TRUE)
source("functions.r") # we'll attach the functions.r file with our submission
options(scipen=999)

wide_stack <- get_stack_df(persist = TRUE, load_from_cache = TRUE)
language_cols <- c("python", "sql", "java", "scala", "r", "julia")

wide_stack <- wide_stack %>%
  mutate(Gender = ifelse(Gender == "Woman", "Female", ifelse(Gender == "Man", "Male", Gender))) %>%
  mutate(Age = as.numeric(as.character(Age)))

long_stack <- wide_stack %>%
  pivot_longer(cols = all_of(language_cols),
               names_to = "Language",
               values_to = "LanguageYesOrNo",
               names_prefix = "language_") %>%
  filter(LanguageYesOrNo == "yes") %>%
  select(Year, Age, Gender, AnnualSalary, Language, Employment, LanguageYesOrNo)

```
_done loading..._ 

---

## The Programming Languages of Data Science

### Language use over time

Python and SQL are the most prevalent languages in 2022. Notably, Julia appears to have exhibited consistent growth since 2017, which makes sense considering it is a relatively new language. The distribution plot is another glimpse of usage changes over time. 

```{r side_by_side_over_time, warning = FALSE, message = FALSE}
language_growth <- long_stack %>%
  filter(LanguageYesOrNo == "yes") %>%
  group_by(Language, Year) %>%
  summarise(Count = n())

p1 <- ggplot(language_growth, aes(x = Year, y= Count, color = Language)) +
  geom_line() +
  ggtitle("Language Use Over Time") + 
  labs( x = "Year", y = "Count of Surveyors" ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Second plot
p2 <- ggplot(long_stack, aes(x = Language, fill = factor(Year))) +
  geom_bar(position = "dodge", width = 0.7) +
  ggtitle("Language Distribution by Year") +
  labs( x = "", y = "Count of Surveyors", fill = "Year" ) +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
grid.arrange(p1, p2, ncol = 2, widths = c(2, 1.5))

```

### Salaries by Year and Language

Let's now look at the distribution of salaries over the years. We will need to create a new data frame that has the following attributes:

-   includes years 2018 to 2022, as 2017's salary data is not in USD
-   includes only those who work full time
-   removes those who make over \$500,000, as the majority of the distributions are below this amount
-   remove those who did not input a salary

The violin plot below illustrates the salary distributions for each language in each year. From the plot, it's apparent that Scala has consistently held the highest average salary among the six languages since 2018.

```{r distribution-of-salaries-over-years-df, message = FALSE, warning = FALSE}
# create a new dataframe 
salary_languages_df <- long_stack %>%
  filter(Year %in% 2018:2022) %>% # not 2017, not in USD
  filter(str_detect(Employment, "full")) %>%
  filter(AnnualSalary < 500000) %>%   # remove suspect outliers 
  select(Year, Age, Gender, AnnualSalary, Language, Employment) 

# Filter out rows with missing AnnualSalary
salary_languages_df <- salary_languages_df[!is.na(salary_languages_df$AnnualSalary), ]

# create plot
ggplot(salary_languages_df, aes(x = Language, y = AnnualSalary, fill = Language)) +
  geom_violin() +
  # to show each year uncomment below
  facet_wrap(~Year) +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle( "Distribution of Salaries for Each Language" ) +
  labs(x = "", y = "Annual Salary (USD)") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none")
```

---

## How does organization size relate to the number of years professionally coding?

```{r ggplot_avg_org_size_by_code_prof}
ggplot(wide_stack, aes(x = YearsCodeProAvg, y = OrgSizeAvg)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Average Organization Size by Average Number of Years Coding Professionally")

```

### The Programming Languages of Data Science: Conclusions

People of all coding experience work for organizations of all different sizes. Most people have coded 0 to 20 years, but people of all coding experiences work for small organizations, medium-sized organizations, and large organizations. There does not seem to be any relationship. The decision to employ workers, and the decision to work at a particular-size company is likely determined on a individual basis. Most organizations likely try to employ people of all different experience levels. Some employees need a lot of experience, while others will gain that experience on the job.

---

## Salaries

### Salaries by Country

```{r}

wide_stack |> 
  filter(!is.na(AnnualSalary)) |> 
  group_by(Country) |> 
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE)) |>
  arrange(-AvgSalary) |>  
  head(n = 15) |>  
  ggplot(aes(x = reorder(Country, AvgSalary), y = AvgSalary)) + 
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Top Average Salaries by Country")
```

### Salaries by Developer Type

```{r}
tempWideStack <- wide_stack
tempWideStack[c('DevType', 'To.Delete')] <- str_split_fixed(tempWideStack$DevType, ';', 2)
tempWideStack <- tempWideStack[,-45]

AvgSalaries <- tempWideStack |> 
  filter(!is.na(AnnualSalary)) |> 
  group_by(DevType) |> 
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE)) |>
  arrange(desc(AvgSalary)) |>
  head(n = 20)

ggplot(AvgSalaries, aes(x = DevType, y = AvgSalary)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Top 20 Average Salaries by Developer Type")

```

### Average Salaries in the U.S. by Developer Type

```{r}

tempWideStack |> 
  filter(!is.na(AnnualSalary)) |> 
  group_by(DevType) |>
  filter((Country == "United States") | (Country == "United States of America")) |>
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE)) |>
  arrange(desc(AvgSalary)) |>
  head(n = 20) |>
  ggplot(aes(x = reorder(DevType, -AvgSalary), y = AvgSalary)) +  # Note: I added reorder() here for ordering in the plot
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Top 20 Average Salaries in the U.S. by Developer Type")
  
```

### Average Salaries in the U.S. by Developer Type (minus blockchain)


```{r excludingBlockchain}

AvgSalaries <- AvgSalaries |> filter(DevType != "Blockchain")
ggplot(AvgSalaries, aes(x = DevType, y = AvgSalary)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Top 19 Average Salaries in the U.S. by Developer Type", subtitle = "Excluding Blockchain Developers")

```

### Salary Distribution vs Age

Let's examine whether age has an influence on salary. We will need to filter for the following:

-   2018 to 2022, as 2017 salaries are not in USD
-   full time employees only
-   remove cases where age is NA

We can see from the below graph that those between ages 23 and 38 have a higher salary distribution than those 18 to 23 and 38 and older. This phenomenon might be attributed to the composition of the respondents in the Stack Overflow survey. It's possible that older professionals in the industry are less inclined to engage with Stack Overflow.

```{r, message = FALSE, warning = FALSE}
wide_stack %>%
  # filter out 2017 since the salaries are not in USD
  filter(Year %in% 2018:2022) %>%
  # filter so only full time employees are included
  filter(str_detect(Employment, "full")) %>%
  # remove rows where age is NA
  filter(!is.na(Age)) %>%
  # create age group categories
  mutate(Age_Group = cut(Age,
                         breaks = c(18, seq(23, 65, by = 5)),  # Create breaks from 18 to 65 in increments of 5
                         labels = paste(seq(18, 60, by = 5), seq(23, 65, by = 5), sep = "-"),
                         right = FALSE)) %>%
  # Select required columns
  select(Year, Age_Group, Gender, AnnualSalary) %>%
  # Directly pipe into ggplot
  ggplot(aes(x = Age_Group, y = AnnualSalary)) +
  geom_point() +
  ggtitle("Age vs. Annual Salary") +
  labs(x = "Age Group", y = "Annual Salary (USD)") +
  theme(plot.title = element_text(hjust = 0.5))
```


### Conclusions: Salaries

Monaco and Afghanistan were the countries with the two highest average annual salaries. Blockchain developers appeared the have the highest salary, but this might be a typo or outlier. Besides blockchain developers, project managers and senior executives had the highest average annual salaries. Specifically in the U.S., blockchain developers also had the highest average annual salaries. Like the rest of the world, project managers and senior executives had the highest annual salaries out of all the job titles.

---

## Job status and degree type

### Count of People with a Specific Job Status by Degree

It seems that the most number of people have a Bachelor's degree and are employed full-time. People are most likely to be employed full-time if they have a Bachelor's degree, Master's degree, or completed some college. Also, people who have a Bachelor's degree are more likely to be self-employed than any other degree. People who only completed high school are most likely to be unemployed. Since most people who took the survey had Bachelor's degrees based on these counts, it may have skewed the results. Also, people are more likely to take this survey if they are employed because they may use Stack Overflow to help them while working at their job.

```{r}

degree_order <- c("High School", "Some college", "Associate's", "Bachelor's", "Professional", "Master's", "Doctorate")

tempWideStack %>%
  select(JobStatus = Employment, Degree = EdLevel) %>%
  mutate(
    JobStatus = case_when(
      grepl("Employed, full-time", JobStatus) ~ "Employed, full-time",
      grepl("Employed, part-time", JobStatus) ~ "Employed, part-time",
      grepl("Not employed", JobStatus) ~ "Not employed",
      grepl("self-employed", JobStatus) ~ "Self-employed",
      grepl("I prefer not to say", JobStatus) ~ NA_character_,
      grepl("Retired", JobStatus) ~ "Retired",
      grepl("Student", JobStatus) ~ "Student",
      TRUE ~ JobStatus
    ),
    Degree = case_when(
      grepl("Associate", Degree) ~ "Associate's",
      grepl("Bachelor", Degree) ~ "Bachelor's",
      grepl("Master", Degree) ~ "Master's",
      grepl("doctoral", Degree) ~ "Doctorate",
      grepl("Some college", Degree) ~ "Some college",
      grepl("Secondary", Degree) ~ "High School",
      grepl("Professional", Degree) ~ "Professional",
      grepl("prefer|never|Primary|Something", Degree) ~ NA_character_,
      TRUE ~ Degree
    )
  ) %>%
  filter(!is.na(Degree), !is.na(JobStatus)) %>%
  mutate(Degree = factor(Degree, levels = degree_order)) %>%
  ggplot(aes(Degree, ..count..)) + 
  geom_bar(aes(fill = JobStatus), position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Count of People with a Specific Job Status by Degree",
       x = "Degree",
       y = "Count of People") +
  scale_fill_brewer(palette = "Set3")
```
---

## Gender and Programming Languages

Surveyors in Average Salary Calculation

### Average Salary for Each Distinct Language

We are interested in examining the average salaries for each distinct programming language, segmented by gender. In order for us to calculate these averages, we need to create a new data frame that has the following attributes:

-   excludes people who know more than one language
-   excludes people who know no languages
-   includes only those who work full time
-   excludes the year 2017, as the 2017 salary data is not in USD

The below plot illustrates the average salary per gender for each distinct language.

```{r calculation-dataframe, warning = FALSE, message = FALSE}
# Determine people with 'yes' in more than one column and remove them
onelanguage_df <- wide_stack %>%
  filter(rowSums(.[, language_cols] == "yes") <= 1) %>%
  # create a new column with the one language each person knows
  mutate(KnownLanguage = case_when(
    python == "yes" ~ "python",
    sql == "yes" ~ "sql",
    java == "yes" ~ "java",
    scala == "yes" ~ "scala",
    r == "yes" ~ "r",
    julia == "yes" ~ "julia",
    TRUE ~ "unknown"  # Handle cases where no language is known
  )) %>%
  # remove the cases where no language is known
  filter(KnownLanguage != "unknown") %>%
  # we're not using 2017 since the salaries are not in USD
  filter(Year %in% 2018:2022) %>%
  # filter so only full time employees are included
  filter(str_detect(Employment, "full")) %>%
  select(Year, Gender, Employment, AnnualSalary, KnownLanguage)

# filter for genders "female" and "male" and find the averages 
# for each language and gender combination
average_salaries <- onelanguage_df %>%
  filter(Gender %in% c("Female", "Male")) %>%
  group_by(Gender, KnownLanguage) %>%
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE))

# Create a bar plot
ggplot(average_salaries, aes(x = KnownLanguage, y = AvgSalary, fill = Gender)) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  ggtitle("Average Salary for Each Distinct Language") +
  labs(x = "Language", y = "Average Salary") +
  scale_fill_manual(values = c("Female" = "hotpink", "Male" = "darkblue")) +
  theme_minimal() + 
  coord_flip()
```

### Count of Surveyors Table

From the previous graph, we see that the average female salary for Scala is an outlier, with its average salary being over \$400,000. To investigate this further, we will construct a table displaying the respondent counts for each scenario.

From the table below, it's apparent that there are only four females in this specific dataset who are proficient in Julia. When considering the actual population of females who exclusively know Julia, this dataset may not provide an accurate representation of their salaries. A similar inference could be made for Scala, as there are only 27 females who exclusively know Scala in contrast to 506 men. However, it's important to note that this dataset accurately reflects the salaries of females who participated in the Stack Overflow survey. In other words, these average salaries are representative of the sample of females who completed the survey, but not the true population of females who know Scala and Julia.

```{r}
# create a table of the counts
counts_avg_salaries <- onelanguage_df %>%
  filter(Gender %in% c("Female", "Male")) %>%
  filter(!is.na(AnnualSalary)) %>%
  group_by(Gender, KnownLanguage) %>%
  mutate(Count = n()) %>%
  select(KnownLanguage, Gender, Count) %>%
  distinct() %>% 
  arrange(KnownLanguage) %>%
  as.data.frame()

# create gt table
counts_avg_salaries_tbl <- gt(counts_avg_salaries) 
  
counts_avg_salaries_tbl <- counts_avg_salaries_tbl |>
  tab_header(
    title = md("**Count of Surveyors in Average Salary Calculation**")
  ) |>
  cols_label(
    KnownLanguage = md("**Language**"),
    Gender = md("**Gender**"),
    Count = md("**Count**")
  )

# show table
counts_avg_salaries_tbl
```

---

## Scala And Python Case Study

### Either or Both? And by Gender

Is there a financial advantage to having proficiency in both Python and Scala compared to solely knowing Scala or Python?

In order to answer this question, we will need to create a new data frame that does the following:

-   filters for years 2018 - 2022, as 2017's salaries are not in USD
-   filter for instances where people know both Scala & Python
-   filter for instances where people know Scala, but not Python
-   filter for instances where people know Python, but not Scala
-   filter for full time employees only

Based on the below graph, we can infer that knowing a combination of the two languages will likely result in a higher salary.

```{r scala-and-python-combinations-df, message = FALSE, warning = FALSE, echo = FALSE}
wide_stack_no2017 <- wide_stack %>%
  # filter for years 2018-2022, since 2017 is not in USD
  filter(Year %in% 2018:2022)

scala_python <- bind_rows(
  wide_stack_no2017 %>%
    # Filter for people who know both Python & Scala
    filter(python == "yes" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, Gender, AnnualSalary) %>%
    mutate(status = "both"),
  
  wide_stack_no2017 %>%
    # Filter for people who know python, but not scala
    filter(python == "yes" & scala == "no") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, Gender, AnnualSalary) %>%
    mutate(status = "python"),
  
  wide_stack_no2017 %>%
    # Filter for people who know scala, but not python
    filter(python == "no" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, Gender, AnnualSalary) %>%
    mutate(status = "scala")
) %>%
  filter(Gender %in% c("Female", "Male")) %>%
  group_by(status, Gender) %>%
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE), .groups = "drop")

ggplot(scala_python, aes(x = status, y = AvgSalary, fill = Gender)) +
  geom_bar(stat = "identity", position = "dodge") +
  ggtitle("Average Salaries for\nScala/Python Combinations") +
  labs(x = "Combination", y = "Average Salary") +
  # center title
  theme(plot.title = element_text(hjust = 0.5)) +
  theme_minimal() 

```

### Over Time

```{r salary over time }

df_scala_pythonYearSalary <- bind_rows(
  wide_stack_no2017 %>%
    # Filter for people who know both Python & Scala
    filter(python == "yes" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, AnnualSalary) %>%
    mutate(status = "both"),
  
  df_python<-wide_stack_no2017%>%
    # Filter for people who know python, but not scala
    filter(python == "yes" & scala == "no") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
     select(Year, AnnualSalary) %>%
    mutate(status = "python"),
  
   df_scala <- wide_stack_no2017 %>%
    # Filter for people who know scala, but not python
    filter(python == "no" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, AnnualSalary)|>
    mutate(status = "scala")
)%>%
  group_by(Year, status)%>%
summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE), .groups = "drop")

colnames(df_scala_pythonYearSalary)[colnames(df_scala_pythonYearSalary) == "status"] <- "Area of Expertise"
ggplot(df_scala_pythonYearSalary,aes(x=Year,y=AvgSalary,size=.3, color=`Area of Expertise`))+geom_path()+ ggtitle("Average Salaries for Scala/Python Combinations (USA) Years 2018-2022\n") +labs(y="Average Salary In USD" ,x="Year")
```

```{r}
wide_stack_no2017$EdLevel<-gsub(r"{\s*\([^\)]+\)}","",as.character(wide_stack_no2017$EdLevel))
wide_stack_no2017US<-wide_stack_no2017%>%filter(str_detect(Country, "United States")) 
EdLevels<-c("Associate degree","Bachelor’s degree","Some college/university study without earning a degree", "Master’s degree","Other doctoral degree","Professional degree")
wide_stack_no2017US<-wide_stack_no2017US%>%filter(wide_stack_no2017US$EdLevel %in% EdLevels)


```


### Level of Education Years

```{r}

df_scala_python_edlevel <- bind_rows(
  wide_stack_no2017US %>%
    # Filter for people who know both Python & Scala
    filter(python == "yes" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, EdLevel, Country, AnnualSalary) %>%
    mutate(status = "both"),
  
  wide_stack_no2017US %>%
    # Filter for people who know python, but not scala
    filter(python == "yes" & scala == "no") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, EdLevel, Country, AnnualSalary) %>%
    mutate(status = "python"),
  
  wide_stack_no2017US %>%
    # Filter for people who know scala, but not python
    filter(python == "no" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, EdLevel, Country, AnnualSalary) %>%
    mutate(status = "scala")
) %>%
  group_by(EdLevel,Year) %>%
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE), .groups = "drop")

df_scala_python_edlevel <- df_scala_python_edlevel[complete.cases(df_scala_python_edlevel), ]
colnames(df_scala_python_edlevel)[colnames(df_scala_python_edlevel) == "EdLevel"] <- "Level of Education"
```

```{r}
ggplot(df_scala_python_edlevel,aes(x=Year,y=AvgSalary, color=`Level of Education`,size=.3))+ geom_path()+ggtitle("Average Salaries for Scala and Python (USA) By Level of Education Years  2018-2022\n")+labs(y="Average Salary in USD" ,x="Year")
```


From the above graphs, we can infer that knowing a combination of the two languages will likely result in a higher salary and despite a drop in the salaries of python developers from 2019 to 2021 there is marked growth in salaries in all areas of expertise in the past 2 years in the United States. The growth of salaries is also seen across all levels of education roughly since 2021. Although the nature of this growth is not entirely clear because the survey was based on individuals self reporting their education.

---

## Links, Sources and URLS

[The Stack Overflow Survey](https://insights.stackoverflow.com/survey)
[Main Project Github](https://github.com/tonythor/krijudato/)
[RPubs](rpubs hyperlink) 
