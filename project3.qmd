---
title: "Project 3"
author: "Krijudato"
date: "October 29, 2023"
output:
  pdf_document: default
  html_document:
    includes:
      in_header: header.html
    css: ./lab.css
    highlight: pygments
    theme: cerulean
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

Tony 
## Abstract
## Introduction
## Data Cleaning
Tony

```{r, warning = FALSE, message = FALSE, output=FALSE}
source("functions.r") # we'll attach the functions.r file with our submission
library(dplyr)
options(scipen=999)
library(tidyr)
library(ggplot2)
library(stringr)
library(gt)
wide_stack <- get_stack_df(persist = TRUE, load_from_cache = TRUE)
language_cols <- c("python", "sql", "java", "scala", "r", "julia")

wide_stack <- wide_stack %>%
  mutate(Gender = ifelse(Gender == "Woman", "Female", ifelse(Gender == "Man", "Male", Gender)))

long_stack <- wide_stack %>%
  pivot_longer(cols = all_of(language_cols),
               names_to = "Language",
               values_to = "LanguageYesOrNo",
               names_prefix = "language_") %>%
  filter(LanguageYesOrNo == "yes") %>%
  select(Year, Age, Gender, AnnualSalary, Language, Employment, LanguageYesOrNo)

```

## Languages Over Time

### Langauges over time 

From the above graph, we can see that Python and SQL are the most commonly used languages as of 2022. Julia seems to have been steadily growing since 2017, which makes sense as it is a relatively new language.

```{r growth-language-time, warning = FALSE, message = FALSE, echo = FALSE}

language_growth <- long_stack %>%
  filter(LanguageYesOrNo == "yes") %>%
  group_by(Language, Year) %>%
  summarise(Count = n())

ggplot(language_growth, aes(x = Year, y= Count, color = Language)) +
  geom_line() +
  ggtitle("Language Use Over Time") + 
  labs(
    x = "Year",
    y = "Surveyor Count"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```



### Distribution over the years. 
Now we can plot the distribution of languages over the years.

```{r dist-languages-over-years-plot, warning = FALSE, message = FALSE, echo = FALSE}
## create a barplot showing the distribution of languages over the years
ggplot(long_stack, aes(x = Language, fill = factor(Year))) +
  geom_bar(position = "dodge", width = 0.7) +
  ggtitle("Language Distribution by Year") +
  labs(
    x = "",
    y = "Count of Surveyors",
    fill = "Year"
  ) +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Salaries by Year, by Language

Let's now look at the distribution of salaries over the years. We will need to create a new data frame that has the following attributes:

- includes years 2018 to 2022, as 2017's salary data is not in USD 
- includes only those who work full time 
- removes those who make over \$500,000, as the majority of the distributions are below this amount 
- remove those who did not input a salary

```{r distribution-of-salaries-over-years-df, message = FALSE, warning = FALSE, echo = FALSE}
# create a new dataframe 
salary_languages_df <- long_stack %>%
  # we're not using 2017 since the salaries are not in USD
  filter(Year %in% 2018:2022) %>%
  # filter so only full time employees are included
  filter(str_detect(Employment, "full")) %>%
  # remove outliers (there are a few outliers with $500k+ salary, majority of the distributions are below 500k)
  filter(AnnualSalary < 500000) %>%
  select(Year, Age, Gender, AnnualSalary, Language, Employment) 

# Filter out rows with missing AnnualSalary
salary_languages_df <- salary_languages_df[!is.na(salary_languages_df$AnnualSalary), ]

# create plot
ggplot(salary_languages_df, aes(x = Language, y = AnnualSalary, fill = Language)) +
  geom_violin() +
  # to show each year uncomment below
  facet_wrap(~Year) +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(
    "Distribution of Salaries for Each Language"
  ) +
  labs(
    x = "", 
    y = "Annual Salary (USD)"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    # remove the legend
    legend.position = "none")
```


## Organization Size and Number of Years Professionally Coding
### Average Organization Size by the Average Number of Years Coding Professionally

It appears that people of all coding experience work for organizations of all different sizes. Most people have coded 0 to 20 years, but people of all coding experiences work for small organizations, medium-sized organizations, and large organizations. There does not seem to be any relationship. The decision to employ workers, and the decision to work at a particular-size company is likely determined on a individual basis. Most organizations likely try to employ people of all different experience levels. Some employees need a lot of experience, while others will gain that experience on the job.

```{r}

ggplot(wide_stack, aes(x = YearsCodeProAvg, y = OrgSizeAvg)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Average Organization Size by Average Number of Years Coding Professionally")

```

## Salaries
### Salaries by Country

Monaco and Afghanistan were the countries with the two highest average annual salaries.

```{r}

AvgSalaries <- wide_stack |> 
  filter(!is.na(AnnualSalary)) |> 
  group_by(Country) |> 
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE)) |>
  arrange(desc(AvgSalary)) |>
  head(n = 11)


ggplot(AvgSalaries, aes(x = Country, y = AvgSalary)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Top 10 Average Salaries by Country")

```

### Salaries by Developer Type

In the code, only the first developer type chosen by each individual was used. This was because people likely chose their main job title first. Each individual in the graph was only represented in one category of "Developer Type" using this logic.

It appeared that blockchain developers have the highest salary. However, this might be an outlier or incorrect data. Besides blockchain developers, project managers and senior executives had the highest average annual salaries. Also, this information may not be correct because individuals input their salaries, which may or may not be correct. Senior executives and blockchain developers are likely paid the most, not project managers.

```{r}
tempWideStack <- wide_stack
tempWideStack[c('DevType', 'To.Delete')] <- str_split_fixed(tempWideStack$DevType, ';', 2)
tempWideStack <- tempWideStack[,-45]

AvgSalaries <- tempWideStack |> 
  filter(!is.na(AnnualSalary)) |> 
  group_by(DevType) |> 
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE)) |>
  arrange(desc(AvgSalary)) |>
  head(n = 20)

ggplot(AvgSalaries, aes(x = DevType, y = AvgSalary)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Top 20 Average Salaries by Developer Type")

```

### Average Salaries in the U.S. by Developer Type

Specifically in the U.S., blockchain developers also had the highest average annual salaries.

```{r}

AvgSalaries <- tempWideStack |> 
  filter(!is.na(AnnualSalary)) |> 
  group_by(DevType) |>
  filter((Country == "United States") | (Country == "United States of America")) |>
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE)) |>
  arrange(desc(AvgSalary)) |>
  head(n = 20)

ggplot(AvgSalaries, aes(x = DevType, y = AvgSalary)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Top 20 Average Salaries in the U.S. by Developer Type")

```


### Average Salaries in the U.S. by Developer Type (minus blockchain)

The following graph was created without blockchain developers because that category had such a high average salary that it was challenging to compare the salaries of other types of developers.

In this graph, we can see that project managers and senior executives had the highest annual salaries out of all the job titles, which is just like the other countries. Again, these two categories may not be the true top two categories (under blockchain) because individuals put in their salaries, and those salaries were never verified.

```{r excludingBlockchain}

AvgSalaries <- AvgSalaries |> filter(DevType != "Blockchain")
ggplot(AvgSalaries, aes(x = DevType, y = AvgSalary)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Top 19 Average Salaries in the U.S. by Developer Type", subtitle = "Excluding Blockchain Developers")

```

### Salary Distribution vs Age

Let's see if there is an impact on salary due to age. We will need to filter for the following: - 2018 to 2022, as 2017 salaries are not in USD - full time employees only - remove cases where age is NA

We can see from the above graph that those between ages 23 and 38 have a higher salary distribution than those 18 to 23 and 38 and older.

```{r, message = FALSE, warning = FALSE, echo = FALSE}
wide_stack$Age <- as.numeric(wide_stack$Age)
# create a new data frame that groups ages into a range
age_vs_salary <- wide_stack %>%
  # filter out 2017 since the salaries are not in USD
  filter(Year %in% 2018:2022) %>%
  # filter so only full time employees are included
  filter(str_detect(Employment, "full")) %>%
  # remove rows where age is NA
  filter(!is.na(Age)) %>%
  # create age group categories
  mutate(Age_Group = cut(Age,
                    breaks = c(18, seq(23, 65, by = 5)),  # Create breaks from 18 to 65 in increments of 5
                    labels = paste(seq(18, 60, by = 5), seq(23, 65, by = 5), sep = "-"),
                    right = FALSE)) %>%
  na.exclude(Age_Group) %>%
  select(Year, Age_Group, Gender, AnnualSalary)
```

```{r, warning = FALSE, message = FALSE, echo = FALSE}
ggplot(age_vs_salary, aes(x = Age_Group, y = AnnualSalary)) +
  geom_point() +
  ggtitle("Age vs. Annual Salary") +
  labs(
    x = "Age Group",
    y = "Annual Salary (USD)"
  ) +
  # center title
  theme(plot.title = element_text(hjust = 0.5))
```


## Job status and degree type

### 

It seems that the most number of people have a Bachelor's degree and are employed full-time. People are most likely to be employed full-time if they have a Bachelor's degree, Master's degree, or completed some college. Also, people who have a Bachelor's degree are more likely to be self-employed than any other degree. People who only completed high school are most likely to be unemployed. Since most people who took the survey had Bachelor's degrees based on these counts, it may have skewed the results. Also, people are more likely to take this survey if they are employed because they may use Stack Overflow to help them while working at their job.

```{r}
jobsAndDegrees <- data.frame(JobStatus = tempWideStack$Employment,
                             Degree = tempWideStack$EdLevel)

jobsAndDegrees$JobStatus <- gsub(".*Employed, full-time.*","Employed, full-time",jobsAndDegrees$JobStatus)
jobsAndDegrees$JobStatus <- gsub(".*Employed, part-time.*","Employed, part-time",jobsAndDegrees$JobStatus)
jobsAndDegrees$JobStatus <- gsub(".*Not employed.*","Not employed",jobsAndDegrees$JobStatus)
jobsAndDegrees$JobStatus <- gsub(".*self-employed.*","Self-employed",jobsAndDegrees$JobStatus)
jobsAndDegrees$JobStatus <- gsub(".*I prefer not to say.*",NA,jobsAndDegrees$JobStatus)
jobsAndDegrees$JobStatus <- gsub(".*Retired.*","Retired",jobsAndDegrees$JobStatus)
jobsAndDegrees$JobStatus <- gsub(".*Student.*","Student",jobsAndDegrees$JobStatus)
jobsAndDegrees$JobStatus <- gsub(".*Employed part-time.*","Employed, part-time",jobsAndDegrees$JobStatus)
jobsAndDegrees$JobStatus <- gsub(".*Employed full-time.*","Employed, full-time",jobsAndDegrees$JobStatus)

jobsAndDegrees$Degree <- gsub(".*Associate.*","Associate's",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Bachelor.*","Bachelor's",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Master.*","Master's",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*doctoral.*","Doctorate",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Bachelor.*","Bachelor's",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Some college.*","Some college",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Doctoral.*","Doctorate",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Secondary.*","High School",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*prefer.*",NA,jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*never.*", NA, jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Professional.*","Professional",jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Primary.*",NA,jobsAndDegrees$Degree)
jobsAndDegrees$Degree <- gsub(".*Something.*",NA,jobsAndDegrees$Degree)

jobsAndDegrees <- jobsAndDegrees |>
  filter(!is.na(Degree)) |>
  filter(!is.na(JobStatus))
ggplot(jobsAndDegrees, aes(Degree, ..count..)) + 
  geom_bar(aes(fill = JobStatus), position = "dodge") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle("Count of People with a Specific Job Status by Degree")

  
```

## Gender and Language

Surveyors in Average Salary Calculation

###  Average Salary for Each Distinct Language

It would be interesting to see the average salaries for each distinct language, split by gender. In order for us to calculate these averages, we need to create a new data frame that has the following attributes:

-   excludes people who know more than one language
-   excludes people who know no languages
-   includes only those who work full time
-   excludes the year 2017, as the 2017 salary data is not in USD

```{r calculation-dataframe, warning = FALSE, message = FALSE, echo = FALSE}
# Determine people with 'yes' in more than one column and remove them
onelanguage_df <- wide_stack %>%
  filter(rowSums(.[, language_cols] == "yes") <= 1) %>%
  # create a new column with the one language each person knows
  mutate(KnownLanguage = case_when(
    python == "yes" ~ "python",
    sql == "yes" ~ "sql",
    java == "yes" ~ "java",
    scala == "yes" ~ "scala",
    r == "yes" ~ "r",
    julia == "yes" ~ "julia",
    TRUE ~ "unknown"  # Handle cases where no language is known
  )) %>%
  # remove the cases where no language is known
  filter(KnownLanguage != "unknown") %>%
  # we're not using 2017 since the salaries are not in USD
  filter(Year %in% 2018:2022) %>%
  # filter so only full time employees are included
  filter(str_detect(Employment, "full")) %>%
  select(Year, Gender, Employment, AnnualSalary, KnownLanguage)

# filter for genders "female" and "male" and find the averages 
# for each language and gender combination
average_salaries <- onelanguage_df %>%
  filter(Gender %in% c("Female", "Male")) %>%
  group_by(Gender, KnownLanguage) %>%
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE))

# Create a bar plot
ggplot(average_salaries, aes(x = KnownLanguage, y = AvgSalary, fill = Gender)) +
  geom_bar(stat = "identity", position = "dodge", color = "black") +
  ggtitle("Average Salary for Each Distinct Language") +
  labs(x = "Language", y = "Average Salary") +
  scale_fill_manual(values = c("Female" = "hotpink", "Male" = "darkblue")) +
  theme_minimal() + 
  coord_flip()
```

### Count of Surveyorsount of

As you can see, the average female salary for Scala is an outlier, with its average salary being over \$400,000. Let's look into this more...



```{r}
# create a table of the counts
counts_avg_salaries <- onelanguage_df %>%
  filter(Gender %in% c("Female", "Male")) %>%
  filter(!is.na(AnnualSalary)) %>%
  group_by(Gender, KnownLanguage) %>%
  mutate(Count = n()) %>%
  select(KnownLanguage, Gender, Count) %>%
  distinct() %>% 
  arrange(KnownLanguage) %>%
  as.data.frame()

# create gt table
counts_avg_salaries_tbl <- gt(counts_avg_salaries) 
  
counts_avg_salaries_tbl <- counts_avg_salaries_tbl |>
  tab_header(
    title = md("**Count of Surveyors in Average Salary Calculation**")
  ) |>
  cols_label(
    KnownLanguage = md("**Language**"),
    Gender = md("**Gender**"),
    Count = md("**Count**")
  )

# show table
counts_avg_salaries_tbl
```

### Conclusions: Gender and Language

We can see from the above table that there are only 4 females in this subset of data that know Julia. In regards to the actual population of females who know only Julia, this would not be an accurate representation of salaries. We could infer the same conclusion about females who know Scala, as there are only 27 females who know only Scala versus 506 men. However, this *would* be an accurate representation of salaries for the sample. In other words, of the females who filled out the stack overflow survey, these average salaries are accurate.


## Case Studies: 

### Scala or Python or Both by Gender

Do people who know both Python and Scala make more money on average than someone who knows only Scala? Only Python?

In order to answer this question, we will need to create a new data frame that does the following:

-   filters for years 2018 - 2022, as 2017's salaries are not in USD
-   filter for instances where people know both Scala & Python
-   filter for instances where people know Scala, but not Python
-   filter for instances where people know Python, but not Scala
-   filter for full time employees only

From the above graph, we can infer that knowing a combination of the two languages will likely result in a higher salary.

```{r scala-and-python-combinations-df, message = FALSE, warning = FALSE, echo = FALSE}
wide_stack_no2017 <- wide_stack %>%
  # filter for years 2018-2022, since 2017 is not in USD
  filter(Year %in% 2018:2022)

scala_python <- bind_rows(
  wide_stack_no2017 %>%
    # Filter for people who know both Python & Scala
    filter(python == "yes" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, Gender, AnnualSalary) %>%
    mutate(status = "both"),
  
  wide_stack_no2017 %>%
    # Filter for people who know python, but not scala
    filter(python == "yes" & scala == "no") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, Gender, AnnualSalary) %>%
    mutate(status = "python"),
  
  wide_stack_no2017 %>%
    # Filter for people who know scala, but not python
    filter(python == "no" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, Gender, AnnualSalary) %>%
    mutate(status = "scala")
) %>%
  filter(Gender %in% c("Female", "Male")) %>%
  group_by(status, Gender) %>%
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE), .groups = "drop")

ggplot(scala_python, aes(x = status, y = AvgSalary, fill = Gender)) +
  geom_bar(stat = "identity", position = "dodge") +
  ggtitle("Average Salaries for\nScala/Python Combinations") +
  labs(x = "Combination", y = "Average Salary") +
  # center title
  theme(plot.title = element_text(hjust = 0.5)) +
  theme_minimal() 

```

### Scala and Python Time

```{r salary over time }

df_scala_pythonYearSalary <- bind_rows(
  wide_stack_no2017 %>%
    # Filter for people who know both Python & Scala
    filter(python == "yes" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, AnnualSalary) %>%
    mutate(status = "both"),
  
  df_python<-wide_stack_no2017%>%
    # Filter for people who know python, but not scala
    filter(python == "yes" & scala == "no") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
     select(Year, AnnualSalary) %>%
    mutate(status = "python"),
  
   df_scala <- wide_stack_no2017 %>%
    # Filter for people who know scala, but not python
    filter(python == "no" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, AnnualSalary)|>
    mutate(status = "scala")
)%>%
  group_by(Year, status)%>%
summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE), .groups = "drop")

colnames(df_scala_pythonYearSalary)[colnames(df_scala_pythonYearSalary) == "status"] <- "Area of Expertise"
ggplot(df_scala_pythonYearSalary,aes(x=Year,y=AvgSalary,size=.3, color=`Area of Expertise`))+geom_path()+ ggtitle("Average Salaries for Scala/Python Combinations (USA) Years 2018-2022\n") +labs(y="Average Salary In USD" ,x="Year")
```

```{r}
wide_stack_no2017$EdLevel<-gsub(r"{\s*\([^\)]+\)}","",as.character(wide_stack_no2017$EdLevel))
wide_stack_no2017US<-wide_stack_no2017%>%filter(str_detect(Country, "United States")) 
EdLevels<-c("Associate degree","Bachelor’s degree","Some college/university study without earning a degree", "Master’s degree","Other doctoral degree","Professional degree")
wide_stack_no2017US<-wide_stack_no2017US%>%filter(wide_stack_no2017US$EdLevel %in% EdLevels)
```
### Level of Education Years
stuff goes here

```{r}

df_scala_python_edlevel <- bind_rows(
  wide_stack_no2017US %>%
    # Filter for people who know both Python & Scala
    filter(python == "yes" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, EdLevel, Country, AnnualSalary) %>%
    mutate(status = "both"),
  
  wide_stack_no2017US %>%
    # Filter for people who know python, but not scala
    filter(python == "yes" & scala == "no") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, EdLevel, Country, AnnualSalary) %>%
    mutate(status = "python"),
  
  wide_stack_no2017US %>%
    # Filter for people who know scala, but not python
    filter(python == "no" & scala == "yes") %>%
    # Filter so only full-time employees are included
    filter(str_detect(Employment, "full")) %>%
    select(Year, EdLevel, Country, AnnualSalary) %>%
    mutate(status = "scala")
) %>%
  group_by(EdLevel,Year) %>%
  summarise(AvgSalary = mean(AnnualSalary, na.rm = TRUE), .groups = "drop")

df_scala_python_edlevel <- df_scala_python_edlevel[complete.cases(df_scala_python_edlevel), ]
colnames(df_scala_python_edlevel)[colnames(df_scala_python_edlevel) == "EdLevel"] <- "Level of Education"
```

```{r}
ggplot(df_scala_python_edlevel,aes(x=Year,y=AvgSalary, color=`Level of Education`,size=.3))+ geom_path()+ggtitle("Average Salaries for Scala and Python (USA) By Level of Education Years  2018-2022\n")+labs(y="Average Salary in USD" ,x="Year")
```

From the above graphs, we can infer that knowing a combination of the two languages will likely result in a higher salary and despite a drop in the salaries of python
developers from 2019 to 2021 there is marked growth in salaries in all areas of
expertise in the past 2 years in the United States.  The growth of salaries is 
also seen across all levels of education roughly since 2021.  Although the nature
of this growth is not entirely clear because the survey was based on individuals
self reporting their education.


## Sources
